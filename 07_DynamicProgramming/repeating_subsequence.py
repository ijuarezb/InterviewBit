#!/usr/bin/env python3
import sys

# Repeating Sub-Sequence
# https://www.interviewbit.com/problems/repeating-subsequence/
#
# Given a string, find if there is any sub-sequence that repeats itself.
# A sub-sequence of a string is defined as a sequence of characters generated by 
# deleting some characters in the string without changing the order of the 
# remaining characters.
#
# Input:
# string
#
# Output:
#
# 0/1
# 0 -> No
# 1 -> Yes
#
# Example:
#
# abab ------> yes, ab is repeated. So, return 1.
# abba ------> No, a and b follow different order. So, return 0.
#
# NOTE : sub-sequence length should be greater than or equal to 2
#
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #


class Solution:

    def lcs(self, A, B):
        n, m = len(A), len(B)

        dp = [[0] * (m + 1) for _ in range(n + 1)]

        for i in range(1, n + 1):
            for j in range(1, m + 1):
                if i == j or A[i - 1] != B[j - 1]:
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
                else:
                    dp[i][j] = dp[i - 1][j - 1] + 1
        return dp[-1][-1]


    # @param A : string
    # @return an integer
    def anytwo(self, A):
        return int(self.lcs(A, A) > 1)

    def repeating_subsequence(self, A):
    	n = m = len(A)
    	dp = [[0] * (n+1) for _ in range(m+1)]

    	for i in range(1, n+1):
    		for j in range(1, m+1):
    			if i != j and A[i-1] == A[j-1]:
    				dp[i][j] = dp[i-1][j-1] + 1
    			else: #i == j or A[i-1] != A[j-1]:
    				dp[i][j] = max(dp[i-1][j], dp[i][j-1])

    	return 1 if dp[n][m] > 1 else 0


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

if __name__ == "__main__":
    s = Solution()
    print(s.anytwo('abab'))
    print(s.repeating_subsequence('abab'))